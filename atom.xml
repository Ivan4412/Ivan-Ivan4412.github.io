<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ivan&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ivan4412.github.io/"/>
  <updated>2018-05-29T12:47:00.489Z</updated>
  <id>https://ivan4412.github.io/</id>
  
  <author>
    <name>Ivan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swagger2构建RESTful API文档</title>
    <link href="https://ivan4412.github.io/2018/05/29/Swagger2%E6%9E%84%E5%BB%BARESTful-API%E6%96%87%E6%A1%A3/"/>
    <id>https://ivan4412.github.io/2018/05/29/Swagger2构建RESTful-API文档/</id>
    <published>2018-05-29T12:35:29.000Z</published>
    <updated>2018-05-29T12:47:00.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h1><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="2-创建类Swagger2"><a href="#2-创建类Swagger2" class="headerlink" title="2. 创建类Swagger2"></a>2. 创建类Swagger2</h1><p>在Application.java同级创建Swagger2的配置类Swagger2  </p><pre><code>@Configuration@EnableSwagger2public class Swagger2 {    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                  .apis(RequestHandlerSelectors.basePackage(&quot;com.didispace.web&quot;)) //扫描该包下所有Controller定义的API                 .paths(PathSelectors.any())                .build();    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)                .description(&quot;yjs的博客：https://ivan4412.github.io/&quot;)                .termsOfServiceUrl(&quot;https://ivan4412.github.io/&quot;)                .contact(&quot;Ivan&apos;Bolg&quot;)                .version(&quot;1.0&quot;)                .build();    }}</code></pre><h1 id="3-RESTful-API接口方法前增加API接口说明"><a href="#3-RESTful-API接口方法前增加API接口说明" class="headerlink" title="3. RESTful API接口方法前增加API接口说明"></a>3. RESTful API接口方法前增加API接口说明</h1><p>在Controller的方法中使用@ApiOperation、@ApiImplicitParams、@ApiImplicitParam注解来增加API说明  </p><pre><code>@ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)@ApiImplicitParams({        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;),        @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)})@RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.PUT)public String putUser(@PathVariable Long id, @RequestBody User user) {    User u = users.get(id);    u.setName(user.getName());    u.setAge(user.getAge());    users.put(id, u);    return &quot;success&quot;;}</code></pre><h1 id="4-swagger文档地址"><a href="#4-swagger文档地址" class="headerlink" title="4. swagger文档地址"></a>4. swagger文档地址</h1><p>启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-添加依赖&quot;&gt;&lt;a href=&quot;#1-添加依赖&quot; class=&quot;headerlink&quot; title=&quot;1. 添加依赖&quot;&gt;&lt;/a&gt;1. 添加依赖&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.spr
      
    
    </summary>
    
      <category term="Spring" scheme="https://ivan4412.github.io/categories/Spring/"/>
    
    
      <category term="SpringBoot" scheme="https://ivan4412.github.io/tags/SpringBoot/"/>
    
      <category term="Swagger2" scheme="https://ivan4412.github.io/tags/Swagger2/"/>
    
      <category term="RESTful" scheme="https://ivan4412.github.io/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>Maven使用总结</title>
    <link href="https://ivan4412.github.io/2018/04/29/Maven%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://ivan4412.github.io/2018/04/29/Maven使用总结/</id>
    <published>2018-04-29T09:31:12.000Z</published>
    <updated>2018-05-29T12:30:09.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Maven是什么？"><a href="#1-Maven是什么？" class="headerlink" title="1. Maven是什么？"></a>1. Maven是什么？</h1><p>Maven是一个跨平台的项目管理工具，它提供了简化和标准化的项目建设过程（构建管理，依赖管理，文档生成及综合项目信息管理。  </p><p>Maven的特点：  </p><blockquote><ol><li>依赖管理。Maven自动下载所需jar，并统一管理项目中Jar包的依赖关系。  </li><li>约定优于配置。约定java源码、资源、测试代码、编译代码存放位置。</li><li>生命周期管理，自动构建。例mvn install就可以自动执行编译，测试，打包等构建过程。</li></ol></blockquote><h1 id="2-Maven目录约定"><a href="#2-Maven目录约定" class="headerlink" title="2. Maven目录约定"></a>2. Maven目录约定</h1><pre><code>MavenProjectRoot(项目根目录)      |----src     |     |----main     |     |         |----java ——存放项目的.java文件     |     |         |----resources ——存放项目资源文件，如spring, hibernate配置文件     |     |----test   |     |         |----java ——存放所有测试.java文件，如JUnit测试类     |     |         |----resources ——存放项目资源文件，如spring, hibernate配置文件     |----target ——项目输出位置     |----pom.xml ----用于标识该项目是一个Maven项目  </code></pre><h1 id="3-POM文件"><a href="#3-POM文件" class="headerlink" title="3.POM文件"></a>3.POM文件</h1><p>POM文件定义了项目的一些基本信息（如，项目坐标/依赖配置/构建配置/项目信息/环境配置）</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0        http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- pom模型版本，maven2和3只能为4.0.0 --&gt;&lt;!-- 父项目基本信息 --&gt;&lt;parent&gt;    &lt;groupId&gt;com.rongdu&lt;/groupId&gt;  &lt;!-- 父项目组ID --&gt;    &lt;artifactId&gt;p2psys&lt;/artifactId&gt; &lt;!--父项目组中的唯一ID--&gt;    &lt;version&gt;2.0.0.0&lt;/version&gt;  &lt;!-- 父项目版本 --&gt;    &lt;relativePath&gt;../p2psys/pom.xml&lt;/relativePath&gt; &lt;!-- 父项目的pom文件存放相对位置 --&gt;&lt;/parent&gt;&lt;!--  子模块配置 --&gt;&lt;modules&gt;    &lt;module&gt;../p2psys-core&lt;/module&gt;    &lt;module&gt;../p2psys-manage&lt;/module&gt;&lt;/modules&gt;&lt;!-- 基本配置 --&gt;&lt;groupId&gt;com.rongdu.p2psys&lt;/groupId&gt;  &lt;!-- 组ID --&gt;&lt;artifactId&gt;p2psys-core-bank&lt;/artifactId&gt; &lt;!--在组中的唯一ID，一般为项目名或模块名 --&gt;&lt;version&gt;2.0.0.0&lt;/version&gt;  &lt;!-- 项目版本 --&gt;&lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 项目打包方式，有以下值：pom, jar, maven-plugin, ejb, war, ear, rar, par --&gt;&lt;!-- 定义变量 --&gt;&lt;properties&gt;    &lt;junit.version&gt;1.7&lt;/junit.version&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;!-- 依赖配置 --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;${junit.version}&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt; &lt;--依赖生命周期管理方式，值可为：compile(默认值)、test、runtime、provided、system --&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--  父项目依赖配置方式；好处是，父项目统一版本，子项目在需要的时候引用 --&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;type&gt;&lt;/type&gt; &lt;!--依赖类型，对应项目坐标定义的packaging，默认不用声明，为jar --&gt;            &lt;optional&gt;&lt;/optional&gt; &lt;!-- 标记依赖是否可选--&gt;            &lt;exclusions&gt; &lt;!-- 排除传递性依赖 --&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;&lt;/artifactId&gt;                    &lt;groupId&gt;&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!--  对应项目依赖配置方式 --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 构建配置 --&gt;&lt;build&gt;    &lt;directory/&gt;  &lt;!--target目录--&gt;    &lt;outputDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。--&gt;      &lt;finalName/&gt; &lt;!--产生的构件的文件名--&gt;     &lt;testOutputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。--&gt;    &lt;sourceDirectory/&gt;  &lt;!--项目源码目录，构建系统会编译目录里的源码，相对于pom.xml的相对路径 --&gt;         &lt;scriptSourceDirectory/&gt;   &lt;!--项目脚本源码目录，该目录下的内容，会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;        &lt;testSourceDirectory/&gt;   &lt;!--项目单元测试使用的源码目录--&gt;        &lt;!--资源路径--&gt;    &lt;resources&gt;             &lt;resource&gt;            &lt;targetPath/&gt;    &lt;!-- 资源的目标路径。相对target/classes目录--&gt;                  &lt;directory/&gt;    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;                &lt;includes/&gt;    &lt;!--包含的模式列表，例如**/*.xml.--&gt;            &lt;excludes/&gt;    &lt;!--排除的模式列表，例如**/*.xml--&gt;          &lt;/resource&gt;        &lt;/resources&gt;     &lt;testResources&gt;      &lt;testResource&gt;        &lt;directory&gt;${project.basedir}/src/test/resources&lt;/directory&gt;      &lt;/testResource&gt;    &lt;/testResources&gt;    &lt;!--使用的插件列表--&gt;     &lt;pluginManagement&gt;       &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;            &lt;version&gt;3.0.2&lt;/version&gt;            &lt;configuration&gt;            &lt;excludes&gt;                &lt;exclude&gt;application.yml&lt;/exclude&gt;            &lt;/excludes&gt;        &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;    &lt;/pluginManagement&gt;   &lt;!--外部构建扩展--&gt;        &lt;extensions&gt;           &lt;extension&gt;               &lt;groupId/&gt;     &lt;!--构建扩展的groupId--&gt;            &lt;artifactId/&gt;    &lt;!--构建扩展的artifactId--&gt;              &lt;version/&gt;      &lt;!--构建扩展的版本--&gt;           &lt;/extension&gt;        &lt;/extensions&gt;&lt;/build&gt;    &lt;!--产生报表的规范--&gt;&lt;reporting&gt;...&lt;/reporting&gt;&lt;!-- 项目信息 --&gt;&lt;name&gt;...&lt;/name&gt;&lt;description&gt;...&lt;/description&gt;&lt;url&gt;...&lt;/url&gt;&lt;inceptionYear&gt;...&lt;/inceptionYear&gt;&lt;licenses&gt;...&lt;/licenses&gt;&lt;organization&gt;...&lt;/organization&gt;&lt;developers&gt;...&lt;/developers&gt;&lt;contributors&gt;...&lt;/contributors&gt;&lt;!-- 环境设置 --&gt;&lt;issueManagement&gt;...&lt;/issueManagement&gt;&lt;ciManagement&gt;...&lt;/ciManagement&gt;&lt;mailingLists&gt;...&lt;/mailingLists&gt;&lt;scm&gt;...&lt;/scm&gt;&lt;prerequisites&gt;...&lt;/prerequisites&gt;&lt;repositories&gt;...&lt;/repositories&gt;&lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;&lt;distributionManagement&gt;...&lt;/distributionManagement&gt;&lt;profiles&gt;...&lt;/profiles&gt;&lt;/project&gt;</code></pre><h1 id="4-Maven的scope属性"><a href="#4-Maven的scope属性" class="headerlink" title="4. Maven的scope属性"></a>4. Maven的scope属性</h1><blockquote><ol><li><strong>compile</strong>：默认值，依赖项目需要参与当前项目的编译，测试，运行周期，打包时需要包含进去。  </li><li><strong>test</strong>：仅参与测试的编译和执行，不会被打包</li><li><strong>runtime</strong>：无需参与项目的编译，但参与后期的测试和运行周期。相比compile，跳过了编译。</li><li><strong>provided</strong>：打包的时候可以不用包进去。相比compile，打包阶段做了exclude操作。</li><li><strong>system</strong>：从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径。</li></ol></blockquote><p><img src="http://p746lkse7.bkt.clouddn.com/Maven%20%E7%AE%80%E4%BB%8B/maven_scope.png" alt="&quot;Maven的scope属性&quot;" title="Maven的scope属性"></p><h1 id="5-可选依赖"><a href="#5-可选依赖" class="headerlink" title="5. 可选依赖"></a>5. 可选依赖</h1><p>该依赖只对当前引用有效，不会向下传导。<br>如果A依赖于B，B中有如下依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.my.C&lt;/groupId&gt;    &lt;artifactId&gt;cpt&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>通过上面配置，optional为true，那么A中就不会依赖这个cpt</p><h1 id="6-排除依赖"><a href="#6-排除依赖" class="headerlink" title="6. 排除依赖"></a>6. 排除依赖</h1><p>如果A–&gt;B,B–&gt;C1，通过排除依赖，A排除对C1的依赖，可替换成C2。<br>A的依赖关系如下配置：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.yjs.b&lt;/groupId&gt;    &lt;artifactId&gt;pro-b&lt;/artifactId&gt;    &lt;version&gt;1.0.1&lt;/version&gt;    &lt;!--排除依赖--&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;com.yjs.c1&lt;/groupId&gt;            &lt;artifactId&gt;pro-c1&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入正确依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.yjs.c2&lt;/groupId&gt;    &lt;artifactId&gt;pro-c2&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="7-Maven常用命令"><a href="#7-Maven常用命令" class="headerlink" title="7. Maven常用命令"></a>7. Maven常用命令</h1><p>Maven常用命令： </p><ol><li><p>创建Maven的普通java项目：</p><pre><code>mvn archetype:create -DgroupId=packageName -DartifactId=projectName  </code></pre></li><li><p>创建Maven的Web项目：</p><pre><code>mvn archetype:create -DgroupId=packageName    -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp    </code></pre></li><li>编译源代码： mvn compile </li><li>编译测试代码：mvn test-compile    </li><li>运行测试：mvn test   </li><li>产生site：mvn site   </li><li>打包：mvn package   </li><li>在本地Repository中安装jar：mvn install </li><li>清除产生的项目：mvn clean   </li><li>生成eclipse项目：mvn eclipse:eclipse  </li><li>生成idea项目：mvn idea:idea  </li><li>组合使用goal命令，如只打包不测试：mvn -Dtest package   </li><li>编译测试的内容：mvn test-compile  </li><li>只打jar包: mvn jar:jar  </li><li>只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile </li><li>清除eclipse的一些系统设置:mvn eclipse:clean  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Maven是什么？&quot;&gt;&lt;a href=&quot;#1-Maven是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Maven是什么？&quot;&gt;&lt;/a&gt;1. Maven是什么？&lt;/h1&gt;&lt;p&gt;Maven是一个跨平台的项目管理工具，它提供了简化和标准化的项目
      
    
    </summary>
    
      <category term="Spring" scheme="https://ivan4412.github.io/categories/Spring/"/>
    
    
      <category term="Maven" scheme="https://ivan4412.github.io/tags/Maven/"/>
    
      <category term="SpringBoot" scheme="https://ivan4412.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java知识点复习</title>
    <link href="https://ivan4412.github.io/2018/04/14/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ivan4412.github.io/2018/04/14/Java知识点复习/</id>
    <published>2018-04-14T12:36:46.000Z</published>
    <updated>2018-04-14T13:25:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h1><ol><li><p>面向对象的特征是什么？  </p><blockquote><p>（封装、继承、多态）  </p></blockquote></li><li><p>继承和组合的区别是什么？什么时候应该用继承、什么时候应该用组合？  </p><blockquote><p>（is-a/has-a）（除非需要向上转型，多用组合，少用继承）    </p></blockquote></li><li><p>Java实现多态的机制是什么？  </p><blockquote><p>（父类的引用变量指向子类的实例对象，动态绑定）</p></blockquote></li><li><p>final关键字的用途？    </p><blockquote><ul><li>变量（基本数据类型值不变，对象引用类型引用不变值可变）</li><li>方法（不可覆盖）</li><li>类（不可继承））  </li></ul></blockquote></li><li><p>class程序代码的装载时机？    </p><blockquote><p>（初始被使用时才被转载（初次包括静态变量和方法使用的时候，可在new之前））  </p></blockquote></li><li><p>为什么要使用内部类，有哪些内部类？他们有什么特点？   </p><blockquote><p>（对外部隐藏、更好封装性，静态内部类（只能访问外部类的静态成员和方法）、成员内部类（需要外部类对象实例才能调用）、方法内部类（可以访问的final定义的方法局部表里）、匿名内部类（只能创建一个对象，无构造函数）  </p></blockquote></li><li><p>HashMap的实现原理？equals()和hashcode()的联系？   </p><blockquote><p>（数组+链表，key值的hashcode()存数组，通过equals()线性比较）  </p></blockquote></li></ol><ol start="8"><li><p>HashMap和HashTable的区别？ </p><blockquote><ul><li>HashTable：方法同步，不允许null值，使用Enumeration进行遍历，hashs数组默认11，增长方式old*2+1，直接使用对象哈希值;<ul><li>HashMap:方法不同步，允许null值，使用Iterator遍历，hash数组默认16，重新计算哈希值）</li></ul></li></ul></blockquote></li><li><p>什么是Java反射，有什么作用，有何优点缺点，实际有什么应用？   </p><blockquote><p>（运行时确定是哪个类，判断对象所属类；动态实例化类对象；动态获得属性方法／调用属性方法，动态创建和编译对象／java多态性；影响一定性能。Java数据库操作/动态代理/Spring ioc/AOP） </p></blockquote></li></ol><h2 id="1-面向对象的特征"><a href="#1-面向对象的特征" class="headerlink" title="1. 面向对象的特征"></a>1. 面向对象的特征</h2><p><img src="http://p746lkse7.bkt.clouddn.com/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81.PNG" alt="&quot;面向对象的特征&quot;" title="面向对象的特征"></p><h2 id="2-继承和组合"><a href="#2-继承和组合" class="headerlink" title="2.继承和组合"></a>2.继承和组合</h2><p>参考：<a href="http://www.hollischuang.com/archives/1319" title="继承和组合" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1319</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、面向对象&quot;&gt;&lt;a href=&quot;#一、面向对象&quot; class=&quot;headerlink&quot; title=&quot;一、面向对象&quot;&gt;&lt;/a&gt;一、面向对象&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;面向对象的特征是什么？  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（封装、继承、多态） 
      
    
    </summary>
    
      <category term="Java" scheme="https://ivan4412.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://ivan4412.github.io/tags/Java/"/>
    
      <category term="面向对象" scheme="https://ivan4412.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Markdown使用入门</title>
    <link href="https://ivan4412.github.io/2018/04/02/Markdown%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://ivan4412.github.io/2018/04/02/Markdown使用入门/</id>
    <published>2018-04-02T11:34:43.000Z</published>
    <updated>2018-08-08T15:32:27.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、特殊字符："><a href="#1、特殊字符：" class="headerlink" title="1、特殊字符："></a>1、特殊字符：</h1><p>对于部分Markdown语法中的特殊字符，需输出原字符的话，使用反斜线：即可。  如： &copy;：\&copy;</p><h1 id="2、换行"><a href="#2、换行" class="headerlink" title="2、换行"></a>2、换行</h1><p>上一行行尾至少有两个及以上的空格</p><h1 id="3、标题："><a href="#3、标题：" class="headerlink" title="3、标题："></a>3、标题：</h1><ol><li><p>类 Setext 形式：<br> 代码:   </p><pre><code>This is an H2  -------------    </code></pre><p> 输出:  </p><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title=" This is an H2  "></a> This is an H2  </h2></li></ol><ol start="2"><li><p>类 Atx 形式:<br> 代码:   </p><pre><code>## 这是 H2  ### 这是 H3 </code></pre><p> 输出：  </p><h2 id="这是-H2"><a href="#这是-H2" class="headerlink" title="这是 H2"></a>这是 H2</h2><h3 id="这是-H3"><a href="#这是-H3" class="headerlink" title="这是 H3"></a>这是 H3</h3></li></ol><h1 id="4、区块引用"><a href="#4、区块引用" class="headerlink" title="4、区块引用"></a>4、区块引用</h1><p>每行的最前面加上 &gt;。<br>代码：  </p><pre><code>&gt; This is a blockquote with two paragraphs. </code></pre><p>输出：</p><blockquote><p>This is a blockquote with two paragraphs. </p></blockquote><p>多重嵌套：<br>代码：  </p><pre><code>&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><p>输出：  </p><blockquote><blockquote><p>This is nested blockquote.</p></blockquote><p>Back to the first level.</p></blockquote><p>嵌套其他 Markdown 语法：<br>代码：  </p><pre><code>&gt; ## 这是一个标题。&gt; &gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p>输出：  </p><blockquote><h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><h1 id="5、列表"><a href="#5、列表" class="headerlink" title="5、列表"></a>5、列表</h1><ol><li><p>无序列表使用星号、加号或是减号作为列表标记：<br> 代码：  </p><pre><code>* Red* yellow+ Green- Blu</code></pre><p> 输出：  </p><ul><li>Red</li><li>yellow</li></ul><ul><li>Green</li></ul><ul><li>Blu</li></ul></li><li><p>有序列表则使用数字接着一个英文句点：(表标记上使用的数字并不会影响输出结果)<br> 代码：  </p><pre><code>2.  Bird1.  McHale3.  Parish</code></pre><p> 输出：  </p><ol start="2"><li>Bird</li><li>McHale</li><li>Parish</li></ol></li><li><p>列表中加入引用，需用&gt; 缩进：<br> 代码：  </p><pre><code>+   A list item with a blockquote:  &gt; This is a blockquote&gt; inside a list item.</code></pre><p> 输出：  </p><ul><li>A list item with a blockquote:  <blockquote><p>This is a blockquote<br>inside a list item.</p></blockquote></li></ul></li></ol><h1 id="6、代码"><a href="#6、代码" class="headerlink" title="6、代码"></a>6、代码</h1><ol><li><p>代码区块：<br> 缩进 4 个空格或是 1 个制表符。  </p><pre><code>这是一个代码区块。</code></pre></li><li><p>标记小段行内代码：<br> 使用反引号把它包起来（`）,对于代码中的`，使用两个反引号括住（`` ) 。<br> 代码：</p><pre><code>Use the `printf()` function.``There is a literal backtick (`) here.``</code></pre><p> 输出：<br> Use the <code>printf()</code> function.<br> <code>There is a literal backtick (`) here.</code></p></li></ol><h1 id="7、分割线"><a href="#7、分割线" class="headerlink" title="7、分割线"></a>7、分割线</h1><p>一行中用三个以上的星号、减号、底线来建立一个分隔线。<br>代码：  </p><pre><code>* * *---</code></pre><p>输出：  </p><hr><hr><h1 id="8、链接"><a href="#8、链接" class="headerlink" title="8、链接"></a>8、链接</h1><ol><li><p>行内式链接：<br>方块括号后面紧接着圆括号并插入网址链接，后面紧接双引号包起的文字可以显示为链接提示文字。<br> 代码：   </p><pre><code>[This link](https://ivan4412.github.io/ &quot;Ivan的博客&quot;) has no title attribute.</code></pre><p> 输出:<br> <a href="https://ivan4412.github.io/" title="Ivan的博客">This link</a> has no title attribute.</p></li><li><p>参考式链接：<br>在文中任意地方使用<br><em>[id]: + 链接地址</em><br>格式记录链接地址。<br>对于需链接文字，在链接文字括号后再接一个方括号，括号中内容为链接的标签id<br> 代码：</p><pre><code>This is [an example][ID1] reference-style link.  [ID1]: https://ivan4412.github.io/  &quot;Ivan的博客&quot;</code></pre><p> 输出：<br> This is <a href="https://ivan4412.github.io/" title="Ivan的博客">an example</a> reference-style link.</p></li></ol><h1 id="9、强调"><a href="#9、强调" class="headerlink" title="9、强调"></a>9、强调</h1><p>使用**或__包住需强调的字词。<br>代码：  </p><pre><code>**single asterisks**  __single underscores__</code></pre><p>输出：<br><strong>single asterisks</strong><br> <strong>single underscores</strong></p><h1 id="10、图片"><a href="#10、图片" class="headerlink" title="10、图片"></a>10、图片</h1><p>图片链接方式和链接类似，亦分为行内式和参考式。</p><ol><li><p>行内式：<br> 使用!开头，紧接方括号括住的图片替代文字，紧接普通括号括住网址<br> 代码：</p><pre><code>![Ivanlogo](https://ivan4412.github.io/img/logo.jpg &quot;Ivan博客Logo&quot;)</code></pre><p> 输出：</p><p> <img src="https://ivan4412.github.io/img/logo.jpg" alt="Ivanlogo" title="Ivan博客Logo"></p></li><li><p>参考式：<br> 使用!开头，紧接方括号括住的图片替代文字，紧接方括号括住的地址标签id。<br> 代码：</p><pre><code>![Ivanlogo][img1]</code></pre><p> 输出：<br> <img src="https://ivan4412.github.io/img/logo.jpg" alt="Ivanlogo" title="Ivan博客Logo"></p></li></ol><h1 id="11、-语法高亮代码块"><a href="#11、-语法高亮代码块" class="headerlink" title="11、 语法高亮代码块"></a>11、 语法高亮代码块</h1><blockquote><p>使用\<figure class="highlight plain"><figcaption><span>(代码块) ``` 包住。  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; \```python  </span><br><span class="line">        def hello():  </span><br><span class="line">            return &apos;Hello World&apos;  </span><br><span class="line">\```    </span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">```python</span><br><span class="line">def hello():  </span><br><span class="line">    return &apos;Hello World&apos;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="12、-脚注"><a href="#12、-脚注" class="headerlink" title="12、 脚注"></a>12、 脚注</h1><p>方括号中的内容以 ^ 开头，再接着是数字、字符串标记  </p><p>例：  </p><blockquote><p>FootNote[\^1]<br>  [\^1]: 我是脚注</p></blockquote><p>输出：<br>FootNote<a href="我是脚注">^1</a></p><h1 id="13、表格"><a href="#13、表格" class="headerlink" title="13、表格"></a>13、表格</h1><p>列与列之间用竖线 | 分隔，第一行为标题，第二行以—-作为强制性分隔线分隔标题和正文。<br>对应列的分隔线添加冒号指定列的对齐方式：</p><ul><li>冒号在分隔线的左边说明此列左对齐 ; </li><li>冒号在分隔线的右边说明此列右对齐  ;</li><li>冒号在分隔线的左右两边说明此列居中 ;  </li></ul><table><thead><tr><th style="text-align:right">&gt; First Header</th><th style="text-align:left">Second Header</th></tr></thead><tbody><tr><td style="text-align:right">Content</td><td style="text-align:left">Content   </td></tr><tr><td style="text-align:right">Content</td><td style="text-align:left">Content       </td></tr></tbody></table><p>输出如下：  </p><table><thead><tr><th style="text-align:right">First Header</th><th style="text-align:left">Second Header</th></tr></thead><tbody><tr><td style="text-align:right">Content</td><td style="text-align:left">Content </td></tr><tr><td style="text-align:right">Content</td><td style="text-align:left">Content </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、特殊字符：&quot;&gt;&lt;a href=&quot;#1、特殊字符：&quot; class=&quot;headerlink&quot; title=&quot;1、特殊字符：&quot;&gt;&lt;/a&gt;1、特殊字符：&lt;/h1&gt;&lt;p&gt;对于部分Markdown语法中的特殊字符，需输出原字符的话，使用反斜线：即可。  如： &amp;copy;
      
    
    </summary>
    
      <category term="Hexo" scheme="https://ivan4412.github.io/categories/Hexo/"/>
    
    
      <category term="Markdown" scheme="https://ivan4412.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github Pages搭建个人博客</title>
    <link href="https://ivan4412.github.io/2018/04/02/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ivan4412.github.io/2018/04/02/Hexo-Github-Pages搭建个人博客/</id>
    <published>2018-04-02T03:25:59.000Z</published>
    <updated>2018-04-13T09:03:25.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、下载安装-Node-js"><a href="#1、下载安装-Node-js" class="headerlink" title="1、下载安装 Node.js"></a>1、下载安装 Node.js</h1><p>下载地址：<em><a href="https://nodejs.org/download/" target="_blank" rel="noopener">https://nodejs.org/download/</a></em>  </p><p>进入release文件夹下载最近版本安装。<br>    <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/downNodejs.jpg" alt="下载安装Nodejs" title="下载安装Node.js"><br>安装完成后，在cmd中输入”path”命令，可查看当前系统环境变量配置情况。其中可以看到nodejs已经配置好。<br>    <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/nodejs_path.png" alt="下载安装Nodejs输入path命令" title="下载安装Node.js"><br>输入node -v，可查看当前版本。<br>    <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/nodejs_version.png" alt="下载安装Nodejs输入node-v" title="下载安装Node.js"></p><h1 id="2、安装Hexo"><a href="#2、安装Hexo" class="headerlink" title="2、安装Hexo"></a>2、安装Hexo</h1><p>npm是随同NodeJS一起安装的包管理工具，安装完Node.js后，可以发现同时npm工具也同时安装好了。</p><ol><li>进入存放博客文件的文件夹下。  </li><li><p>安装hexo命令:  </p><pre><code>npm install hexo-cli -g  </code></pre><p> 输入：hexo -v后，可以看到hexo命令安装完成。</p></li><li><p>初始化hexo :   </p><pre><code>init blog</code></pre></li><li><p>进入blog文件夹后安装hexo的扩展插件：  </p><pre><code>npm install</code></pre></li><li><p>生成网站静态文件：</p><pre><code>hexo g # 或者hexo generate</code></pre></li><li><p>启动hexo本地web服务：  </p><pre><code>hexo s # 或者hexo server</code></pre></li><li><p>启动服务后，可以在 <em><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></em> 查看内置生成的博客。<br><img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_localhost_demo.png" alt="hexo内置生成的博客" title="Hexo内置博客"></p></li></ol><h1 id="3、下载安装Git"><a href="#3、下载安装Git" class="headerlink" title="3、下载安装Git"></a>3、下载安装Git</h1><p>下载地址：<em><a href="https://git-scm.com/download/" target="_blank" rel="noopener">https://git-scm.com/download/</a></em>    </p><p>命令提示符中输入“path”命令，可以看到：<br><img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git_path.png" alt="Git_path" title="git_path"> </p><p>命令提示符中输入git version，查看安装好的版本。<br><img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git_version.png" alt="Git_version" title="git_version"> </p><h1 id="4、Github-Pages设置"><a href="#4、Github-Pages设置" class="headerlink" title="4、Github Pages设置"></a>4、Github Pages设置</h1><p>GitHub Pages 是托管在GitHub的项目，可以通过 <em><a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></em> 来访问托管在Github个人主页，前提是仓库的名字必须是 <em>username.github.io</em> ，每个账户只能有一个这样的仓库来托管主页。</p><ol><li><p>GitHub上建立专门存放主页的仓库<br> 通过new repository新增一个仓库。<br> <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/create_new_repository.png" alt="新增Github仓库" title="新增Github仓库">  </p><p> 在Setting中，以 <em>username.github.io</em> 的形式命名新建的仓库。<br> <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github_setting.png" alt="新增Github仓库Setting配置" title="新增Github仓库Setting配置"> </p><p> 注意GitHub Pages的Source中选中master branch。<br> <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github_setting_pages.png" alt="新增Github仓库GitHubPagesg配置" title="新增Github仓库GitHubPages配置"></p><p> 这样通过 <em><a href="https://ivan4412.github.io/">https://ivan4412.github.io/</a></em> ，就可以访问github新建的主页了。<br> <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github__pages_demo.png" alt="GitHubPagesg_DEMO" title="GitHubPagesg_DEMO"></p></li><li><p>部署Hexo到Github Pages<br>通过之前的步骤，我们已经启用了github上的个人主页，但是这并不是我们所需要的。接下来，我们需要通过hexo generate命令 成一个静态网站，并将这个静态网站，部署到github上。</p><p> 2.1. 修改配置文件blog/_config.yml，找到deploy项，修改如下内容:  </p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  # 类型  type: git  # 仓库  repo: git@github.com:Ivan4412/Ivan4412.github.io.git  # 分支  branch: master</code></pre><p> 注意：各项冒号后面需紧接着一个空格。</p><p> 2.2. 部署hexo  </p><pre><code>通过hexo命令部署hexo到GitHub中:  # 清空静态页面hexo clean #（或hexo c）# 生成静态页面hexo generate #（或hexo g）# 部署 hexo deploy #（或hexod ）</code></pre></li></ol><h1 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h1><ul><li><p>问题1：如果此时产生 ERROR Deployer not found: git错误。</p><p> 这是由于hexo缺少git扩展的拓展插件，执行如下命令安装即可：  </p><pre><code>npm install --save hexo-deployer-git</code></pre></li></ul><ul><li><p>问题2：执行hexo deploy，报错：  </p><pre><code>Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.</code></pre><p>  使用git协议提交项目，需要配置相应的密钥对。首先需生成本地密钥对 ，然后将对应的公钥设置到远程远程仓库上。 </p><ol><li><p>生成SSH-Key  </p><p> 进入Git安装目录下，找到git-bash.exe,执行如下命令：  </p><pre><code>git config --global user.name &quot;用户名称&quot;git config --global user.email &quot;邮件地址@youremail.com &quot;ssh-keygen -t rsa -C 邮件地址@youremail.com</code></pre><p> 按提示生成SSH key，期间会要求输入密码，这个密码会在提交项目时用到，主要是防止别人随意提交项目内容。或者也可以不输入，这样就下次提交时就可以直接提交。<br> <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-keygen.png" alt="SSH-keygen" title="SSH-keygen"></p><pre><code>Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;</code></pre></li><li><p>将SSH Key 添加到 GitHub<br> 打开本地 id_rsa.pub 文件，将其内容拷贝到GitHub的Deploy Keys中（路径为：Settings/DeployKeys,注意勾选Allow write access）<br> <img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh_deploy_keys.png" alt="将SSHKey添加到GitHub" title="将SSHKey添加到GitHub"><br> 使用SSH命令，验证是否链接到了github:  </p><pre><code>ssh -T git@github.com </code></pre><p><img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-t_github.png" alt="验证是否链接到了github" title="验证是否链接到了github"><br>再次部署，运行hexo deploy  </p><p>访问 <em><a href="https://ivan4412.github.io/">https://ivan4412.github.io/</a></em>，就可以看到部署到Github中的个人主页。<br><img src="http://p746lkse7.bkt.clouddn.com/Hexo_Github_Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github_demo.png" alt="ivan4412_demo" title="ivan4412_demo"></p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、下载安装-Node-js&quot;&gt;&lt;a href=&quot;#1、下载安装-Node-js&quot; class=&quot;headerlink&quot; title=&quot;1、下载安装 Node.js&quot;&gt;&lt;/a&gt;1、下载安装 Node.js&lt;/h1&gt;&lt;p&gt;下载地址：&lt;em&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="Hexo" scheme="https://ivan4412.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://ivan4412.github.io/tags/Hexo/"/>
    
      <category term="Github Pages" scheme="https://ivan4412.github.io/tags/Github-Pages/"/>
    
  </entry>
  
</feed>
